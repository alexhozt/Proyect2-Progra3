# Para Inciarl Streamlit usa python -m streamlit run visual/dashboard.py

#HAY UNOS WARNINGS DE MATPLOTLIB ES QUE CUANODO SE GENERAN LOS NODOS SE CREAN CON UNOS EMOJIS QUE NO SON CAPACES DE PROCESAR HAY
#QUE QUITARLOS ESO Xd

import streamlit as st
from visual.network_adapter import NetworkXAdapter
from simulacion.init_simulation import generar_red
from simulacion.simulation import Simulation
from visual.avl_visualizer import AVLVisualizer
import random
import pandas as pd
from collections import deque
import plotly.express as px
import math
from streamlit_folium import folium_static
from visual.MAP.map_visualizer import generar_mapa  
import networkx as nx 
from visual.generator_report import generar_pdf


def calcular_mst(graph):
    import networkx as nx  # por si est√° afuera

    G = nx.Graph()
    
    for v in graph.vertices():
        G.add_node(str(v))
    
    for e in graph.edges():
        u, v = e.endpoints()
        peso = e.element()
        G.add_edge(str(u), str(v), weight=peso)

    mst = nx.minimum_spanning_tree(G, algorithm="kruskal")
    mst_edges = [(u, v, mst[u][v]["weight"]) for u, v in mst.edges()]
    return mst_edges


def calcular_ruta_optima(graph, origen, destino, algoritmo="Dijkstra", max_autonomia=50):
    import networkx as nx
    G = nx.DiGraph()

    for v in graph.vertices():
        G.add_node(str(v))

    for e in graph.edges():
        u, v = e.endpoints()
        G.add_edge(str(u), str(v), weight=e.element())

    def calcular_camino(source, target):
        try:
            if algoritmo == "Dijkstra":
                path = nx.dijkstra_path(G, str(source), str(target), weight="weight")
                cost = nx.dijkstra_path_length(G, str(source), str(target), weight="weight")
            elif algoritmo == "Floyd-Warshall":
                pred, dist = nx.floyd_warshall_predecessor_and_distance(G, weight="weight")
                path = []
                current = str(target)
                while current != str(source):
                    path.insert(0, current)
                    current = pred[str(source)][current]
                path.insert(0, str(source))
                cost = dist[str(source)][str(target)]
            else:
                return None, None
            return path, cost
        except:
            return None, None

    # Intentar ruta directa
    path, cost = calcular_camino(origen, destino)
    if path and cost <= max_autonomia:
        return path, cost

    # Si supera autonom√≠a, buscar v√≠a recarga
    recargas = [v for v in graph.vertices() if str(v).startswith("üîã")]
    for nodo_recarga in recargas:
        tramo1, cost1 = calcular_camino(origen, nodo_recarga)
        tramo2, cost2 = calcular_camino(nodo_recarga, destino)
        if tramo1 and tramo2 and cost1 <= max_autonomia and cost2 <= max_autonomia:
            nueva_ruta = tramo1[:-1] + tramo2  # evitar repetir nodo recarga
            nuevo_costo = cost1 + cost2
            return nueva_ruta, nuevo_costo

    # No se encontr√≥ ruta v√°lida
    return None, None



# Configuraci√≥n de la interfaz
st.set_page_config(page_title="Sistema de Drones", layout="wide")

if "mostrar_mst" not in st.session_state:
    st.session_state["mostrar_mst"] = False


# Sidebar de navegaci√≥n (5 pesta√±as)
tabs = st.tabs(["üîÑ Run Simulation", "üåç Explore Network", "üåê Clients & Orders", "üìã Route Analytics", "üìà General Statistics"])

# ============================
# üîÑ PESTA√ëA 1: Run Simulation
# ============================

with tabs[0]:
    st.header("üîÑ Simulaci√≥n de Red de Drones")

    st.markdown("Configura los par√°metros para iniciar la simulaci√≥n:")

    n_nodes = st.slider("N√∫mero de nodos", min_value=10, max_value=150, value=15)
    m_edges = st.slider("N√∫mero de aristas", min_value=n_nodes - 1, max_value=min(300, n_nodes*(n_nodes - 1)//2), value=20)
    n_orders = st.slider("N√∫mero de √≥rdenes", min_value=10, max_value=300, value=10)

    n_almacen = int(n_nodes * 0.20)
    n_recarga = int(n_nodes * 0.20)
    n_clientes = n_nodes - n_almacen - n_recarga

    st.markdown("""
    **Distribuci√≥n de nodos:**  
    üì¶ Almacenamiento: {} (20%)  
    üîã Recarga: {} (20%)  
    üë§ Clientes: {} (60%)
    """.format(n_almacen, n_recarga, n_clientes))

    if st.button("üìä Start Simulation"):
        graph, sim = generar_red(n_nodes, m_edges, n_almacen, n_recarga, n_clientes)
        st.session_state["graph"] = graph
        st.session_state["sim"] = sim


        # Registrar clientes autom√°ticamente
        for i in range(n_clientes):
            client_id = f"C{i:03}"
            name = f"Cliente {i}"
            client_type = random.choice(["premium", "normal"])
            sim.register_client(client_id, name, client_type)

        # Funci√≥n para encontrar rutas v√°lidas con BFS
        def bfs(graph, start, end):
            visited = set()
            queue = deque([(start, [start], 0)])

            while queue:
                current, path, cost = queue.popleft()
                if current == end:
                    return path, cost
                for neighbor in graph.neighbors(current):
                    if neighbor not in path:
                        edge = graph.get_edge(current, neighbor)
                        queue.append((neighbor, path + [neighbor], cost + edge.element()))
            return None, None

        vertices = list(graph.vertices())
        client_nodes = [v for v in graph.vertices() if str(v).startswith("üë§")]
        if len(client_nodes) >= 2:
            for i in range(n_orders):
                origin = random.choice(client_nodes)
                destination = random.choice([v for v in client_nodes if v != origin])
                path, cost = bfs(graph, origin, destination)
                if path:
                    sim.create_order(f"C{i:03}", origin, destination, priority=1, path=path, cost=cost)

        st.session_state["graph"] = graph
        st.session_state["sim"] = sim
        st.session_state["simulation_started"] = True
        st.session_state["adapter"] = NetworkXAdapter(graph)

        st.success("Simulaci√≥n iniciada correctamente üöÄ")

# =============================
# üåç PESTA√ëA 2: Explore Network
# =============================
with tabs[1]:
    st.header("üåç Explora la Red de Drones")

    if st.session_state.get("simulation_started"):
        graph = st.session_state["graph"]
        sim = st.session_state["sim"]

        st.subheader("üó∫Ô∏è Visualizaci√≥n en Mapa Real")

        # Solo generar nodos/aristas una vez
        if "nodos" not in st.session_state or "aristas" not in st.session_state:
            nodos = []
            aristas = []
            for v in graph.vertices():
                label = str(v)
                tipo = label[0]
                lat = -38.735 + random.uniform(-0.01, 0.01)
                lon = -72.590 + random.uniform(-0.01, 0.01)
                nodos.append((label, lat, lon, tipo))

            for e in graph.edges():
                u, v = e.endpoints()
                aristas.append((str(u), str(v), e.element()))

            st.session_state["nodos"] = nodos
            st.session_state["aristas"] = aristas

        ruta = st.session_state.get("ruta")
        mst_resultado = st.session_state.get("mst_resultado")

        st.subheader("‚úà Calcular Ruta entre Nodos")

        origenes = [v for v in graph.vertices() if str(v).startswith("üì¶")]
        destinos = [v for v in graph.vertices() if str(v).startswith("üë§")]

        origen = st.selectbox("üì¶ Nodo de Origen (Almacenamiento)", origenes, format_func=str)
        destino = st.selectbox("üë§ Nodo de Destino (Cliente)", destinos, format_func=str)

        algoritmo = st.radio("‚öôÔ∏è Algoritmo de Ruta", ["Dijkstra", "Floyd-Warshall"])

        if st.button("‚úà Calcular Ruta"):
            path, cost = calcular_ruta_optima(graph, origen, destino, algoritmo)
            if path:
                st.session_state["ruta"] = path
                st.session_state["ruta_costo"] = cost
                ruta = path
                st.success(f"Ruta con {algoritmo}: {' ‚Üí '.join(ruta)} | Costo total: {cost}")

                recarga_en_ruta = any("üîã" in n for n in ruta)
                tiempo_estimado = round(cost * 1.2, 2)

                with st.expander("üìù Resumen de vuelo"):
                    st.markdown(f"**Nodos visitados:** {len(ruta)}")
                    st.markdown(f"**Ruta completa:** {' ‚Üí '.join(ruta)}")
                    st.markdown(f"**Distancia total:** {cost} unidades")
                    st.markdown(f"**Tiempo estimado de vuelo:** {tiempo_estimado} minutos")
                    st.markdown(f"**Recarga necesaria:** {'‚úÖ S√≠' if recarga_en_ruta else '‚ùå No'}")
            else:
                st.error("No se encontr√≥ una ruta v√°lida entre esos nodos.")

        st.subheader("üå≤ √Årbol de Expansi√≥n M√≠nima (Kruskal)")

        col1, col2 = st.columns(2)
        with col1:
            if st.button("üå≤ Mostrar MST"):
                mst_resultado = calcular_mst(graph)
                st.session_state["mst_resultado"] = mst_resultado
                st.success(f"MST calculado con {len(mst_resultado)} conexiones.")
        with col2:
            if st.button("‚ùå Ocultar MST"):
                st.session_state["mst_resultado"] = None
                mst_resultado = None

        # Mostrar mapa final con ruta y/o MST persistente
        mapa = generar_mapa(
            st.session_state["nodos"],
            st.session_state["aristas"],
            ruta=st.session_state.get("ruta"),
            mst=st.session_state.get("mst_resultado")
        )
        if mapa:
            folium_static(mapa)
        else:
            st.error("No se pudo generar el mapa.")

    else:
        st.info("Primero inicia una simulaci√≥n en la pesta√±a anterior.")
                


        

# ==========================
# üåê PESTA√ëA 3: Clients & Orders
# ==========================

with tabs[2]:
    st.header("üåê Clients and Orders")

    if st.session_state.get("simulation_started"):
        sim = st.session_state["sim"]

        st.subheader("üë§ Clients")
        clients = sim.get_clients()
        if clients:
            for client in clients:
                if "type" not in client:
                    client["type"] = random.choice(["premium", "normal"])
            st.dataframe(pd.DataFrame(clients))
        else:
            st.info("No hay clientes registrados todav√≠a.")

        st.subheader("üì¶ Orders")
        orders = sim.get_orders()
        if orders:
            # Ajustar visualizaci√≥n del campo delivered_at
            for order in orders:
                if order["delivered_at"] in [None, "null", "", "None"]:
                    order["delivered_at"] = "A√∫n no se complet√≥ el env√≠o"
            st.dataframe(pd.DataFrame(orders))
        else:
            st.info("No hay √≥rdenes registradas todav√≠a.")
    else:
        st.info("Inicia una simulaci√≥n para ver clientes y √≥rdenes.")


# =============================
# üìã PESTA√ëA 4: Route Analytics
# =============================

with tabs[3]:
    st.header("üìã Rutas frecuentes")

    if "sim" in st.session_state:
        sim = st.session_state["sim"]
        rutas = sim.get_frequent_routes()

        if rutas:
            rutas.sort()  # Ordenar por recorrido (orden lexicogr√°fico)

            st.subheader("üìã Rutas m√°s frecuentes")
            for i, (ruta, freq) in enumerate(rutas, start=1):
                st.markdown(f"{i}. Route hash: {ruta} | Frequency: {freq}")

            st.subheader("üìä AVL Tree Visualization")
            from visual.avl_visualizer import AVLVisualizer
            visualizer = AVLVisualizer(sim.routes_avl)
            visualizer.draw(use_hierarchy=True)

            st.subheader("üìÑ Generar Informe PDF")

            if st.button("üìÑ Generar Informe"):
                orders = sim.get_orders()
                clients = sim.get_clients()
                rutas_frecuentes = sim.get_frequent_routes()

                from generator_report import generar_pdf, guardar_graficos_pdf
                graph = st.session_state["graph"]
                
                guardar_graficos_pdf(graph, sim)  # üíæ genera los .png antes del PDF

                ruta_pdf = generar_pdf(orders, clients, rutas_frecuentes)
                with open(ruta_pdf, "rb") as file:
                    st.download_button("‚¨áÔ∏è Descargar Informe PDF", file, file_name="informe_drones.pdf")


        else:
            st.warning("No hay rutas registradas a√∫n.")
    else:
        st.info("Inicia una simulaci√≥n para analizar rutas.")



# ==============================
# üìà PESTA√ëA 5: General Statistics
# ==============================



with tabs[4]:
    st.header("üìà General Statistics")
    st.write("DEBUG - graph:", "OK" if "graph" in st.session_state else "MISSING")
    st.write("DEBUG - sim:", "OK" if "sim" in st.session_state else "MISSING")

    graph = st.session_state.get("graph")
    sim = st.session_state.get("sim")

    if graph and sim:
        roles = {"üì¶": "Storage", "üîã": "Recharge", "üë§": "Client"}
        role_counts = {"üì¶": 0, "üîã": 0, "üë§": 0}
        visit_counts = {"üì¶": {}, "üîã": {}, "üë§": {}}

        for v in graph.vertices():
            name = str(v)
            for symbol in roles:
                if name.startswith(symbol):
                    role_counts[symbol] += 1
                    visit_counts[symbol][name] = 0

        # Simulaci√≥n: contar visitas reales por nodo en las rutas
        for order in sim.get_orders():
            for node in order.get("path", []):
                node_str = str(node)
                for symbol in visit_counts:
                    if node_str in visit_counts[symbol]:
                        visit_counts[symbol][node_str] += 1

        labels = [roles[k] for k in role_counts]
        sizes = [int(role_counts[k]) if role_counts[k] and not math.isnan(role_counts[k]) else 0 for k in role_counts]

        if sum(sizes) > 0:
            st.subheader("üìä Top Visited Nodes by Role")

            col1, col2, col3 = st.columns(3)
            cols = {"üë§": col1, "üîã": col2, "üì¶": col3}

            for symbol in ["üë§", "üîã", "üì¶"]:
                sorted_visits = sorted(visit_counts[symbol].items(), key=lambda x: x[1], reverse=True)[:5]
                if sorted_visits:
                    df_bar = pd.DataFrame(sorted_visits, columns=["Nodo", "Visitas"])
                    fig = px.bar(
                        df_bar,
                        x="Nodo",
                        y="Visitas",
                        title=f"Most Visited {roles[symbol]} Nodes",
                        text_auto=True
                    )
                    fig.update_traces(marker_color="#1E65C9", hovertemplate="Nodo: %{x}<br>Visitas: %{y}")
                    with cols[symbol]:
                        st.plotly_chart(fig, use_container_width=True)

            # ü•ß Gr√°fico de torta - proporci√≥n de roles
            st.subheader("ü•ß Pie Chart: Node Role Distribution")
            df_pie = pd.DataFrame({
                "Rol": labels,
                "Cantidad": sizes
            })
            fig_pie = px.pie(df_pie, values="Cantidad", names="Rol", title="Distribuci√≥n de Roles", hole=0.3)
            st.plotly_chart(fig_pie, use_container_width=True)
        else:
            st.warning("No hay nodos registrados para mostrar estad√≠sticas.")
    else:
        st.warning("No se encontr√≥ un grafo generado o simulaci√≥n activa.")